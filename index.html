<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RepSpheres: Elevating Elite Sales Teams with Precision Intelligence</title>
    <!-- Link to the external CSS file -->
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="stars" id="stars"></div>

    <nav class="navbar compact-navbar">
      <div class="navbar-brand">
        <svg class="logo" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="10" stroke="var(--accent-color)" stroke-width="2"/>
          <circle cx="12" cy="12" r="5" fill="var(--accent-color)"/>
        </svg>
        <span>RepSpheres</span>
      </div>
      <div class="nav-links">
        <a href="/dashboard/blog.html" class="nav-link"><span class="nav-icon">üìù</span> Blogs</a>
        <a href="/dashboard/podcast.html" class="nav-link"><span class="nav-icon">üéôÔ∏è</span> Podcasts</a>
        <a href="/dashboard/market.html" class="nav-link"><span class="nav-icon">üìà</span> Market iQ</a>
      </div>
      <button id="login-btn" class="cta-button dropdown-btn">
        Sign Up / Login
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 12H19M19 12L12 5M19 12L12 19" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
      <div id="login-dropdown" class="dropdown hidden">
        <button id="google-signin-btn" class="dropdown-item">
          <span style="display:flex;align-items:center;gap:10px;">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/google/google-original.svg" alt="Google" style="width:22px;height:22px;vertical-align:middle;filter: drop-shadow(0 0 4px var(--neon-purple));">
            <span style="font-weight:600;letter-spacing:0.01em;">Sign in with Google</span>
          </span>
        </button>
      </div>
    </nav>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
    <script>
      // Initialize Supabase client
      const SUPABASE_URL = 'https://cbopynuvhcymbumjnvay.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNib3B5bnV2aGN5bWJ1bWpudmF5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM5OTUxNzMsImV4cCI6MjA1OTU3MTE3M30.UZElMkoHugIt984RtYWyfrRuv2rB67opQdCrFVPCfzU';
      const _supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      // Show admin dropdown if user is admin
      const adminEmail = 'jasonwilliamgolden@gmail.com';
      _supabase.auth.getUser().then(({ data: { user } }) => {
        if (user && user.email === adminEmail) {
          document.getElementById('nav-admin').style.display = 'flex';
        }
      });
      // Dropdown toggle
      document.getElementById('admin-dropdown-btn').onclick = function(e) {
        e.stopPropagation();
        document.getElementById('admin-dropdown').classList.toggle('hidden');
      };
      document.body.onclick = function() {
        document.getElementById('admin-dropdown').classList.add('hidden');
      };
      document.getElementById('admin-dropdown').onclick = function(e) {
        e.stopPropagation();
      };
    </script>

    <section class="hero" id="hero">
        <div style="position:relative; width:100%; height:400px; display:flex; align-items:center; justify-content:center; z-index:1; margin-bottom:2rem;">
          <svg id="orbSVG" viewBox="0 0 800 800" style="width:400px; height:400px; display:block; background:transparent; position:relative; z-index:2;">
            <defs>
              <radialGradient id="parentGrad" cx="50%" cy="50%" r="70%">
                <stop id="p0" offset="0%" stop-color="#00E5FF"/>
                <stop id="p1" offset="100%" stop-color="#5B3CFF"/>
                <stop id="p2" offset="50%" stop-color="#00E5FF"/>
                <stop id="p3" offset="75%" stop-color="#5B3CFF"/>
              </radialGradient>
              <radialGradient id="childGrad0" cx="50%" cy="50%" r="70%">
                <stop id="c0s0" offset="0%" stop-color="#B3D8FF"/>
                <stop id="c0s1" offset="100%" stop-color="#0A192F"/>
              </radialGradient>
              <radialGradient id="childGrad1" cx="50%" cy="50%" r="70%">
                <stop id="c1s0" offset="0%" stop-color="#C6FFD9"/>
                <stop id="c1s1" offset="100%" stop-color="#145A32"/>
              </radialGradient>
              <radialGradient id="childGrad2" cx="50%" cy="50%" r="70%">
                <stop id="c2s0" offset="0%" stop-color="#FFB3C9"/>
                <stop id="c2s1" offset="100%" stop-color="#7B1F3A"/>
              </radialGradient>
              <radialGradient id="childGrad3" cx="50%" cy="50%" r="70%">
                <stop id="c3s0" offset="0%" stop-color="#E0D1FF"/>
                <stop id="c3s1" offset="100%" stop-color="#311B4F"/>
              </radialGradient>
              <radialGradient id="childGrad4" cx="50%" cy="50%" r="70%">
                <stop id="c4s0" offset="0%" stop-color="#FFF5B3"/>
                <stop id="c4s1" offset="100%" stop-color="#4B3800"/>
              </radialGradient>

            </defs>
            <path id="parentOrb" fill="url(#parentGrad)" opacity="0.95"/>
            <g id="children"></g>
          </svg>
        </div>
        <h1>Sales<br><span>Intelligence</span><br>Evolved</h1>
        <p>Transform your elite sales team with AI-driven psychological insights that decode buyer motivations, personalize every interaction, and engineer predictable outcomes.</p>
    </section>
        <button class="cta-button">
            Request RepSpheres
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 12H19M19 12L12 5M19 12L12 19" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
    </section>

    <section class="section" id="problem">
        <h2 class="section-title">The Problem with Fragmented Intelligence</h2>
        <div class="card-container">
            <div class="card">
                <h3>Tool Overload</h3>
                <p>Elite reps are drowning in tools, not empowered by them. The cognitive load of switching between systems creates friction that kills productivity.</p>
            </div>
            <div class="card">
                <h3>Lost Momentum</h3>
                <p>Great reps lose momentum when insight, timing, and messaging aren't synced. Every context switch is a potential point of failure.</p>
            </div>
            <div class="card">
                <h3>Generic Outreach</h3>
                <p>Despite having rich data, most sales communications remain generic and uninspired, failing to leverage psychological triggers that drive action.</p>
            </div>
        </div>
    </section>

    <div class="parallax" style="background: linear-gradient(135deg, #361d5a 0%, #8a4fff 100%);">
        <div class="parallax-content">
            <h2>Enter RepSpheres</h2>
            <p>The AI-driven intelligence layer that transforms how elite sales teams connect, communicate, and close.</p>
        </div>
    </div>

    <section class="section" id="solution">
        <h2 class="section-title">The Proprietary Engine: 150 Psychological Triggers</h2>
        <p>RepSpheres doesn't just connect your tools‚Äîit thinks with them, turning data into insights and insights into action.</p>
        <div class="card-container">
            <div class="card">
                <h3>Psychological Scanning</h3>
                <p>Every lead is scanned against 150 proven psychological triggers, from curiosity and status to scarcity and social proof.</p>
            </div>
            <div class="card">
                <h3>Automated Personalization</h3>
                <p>Content is automatically created to align with what moves each prospect, eliminating guesswork and generic messaging forever.</p>
            </div>
            <div class="card">
                <h3>Data Unification</h3>
                <p>RepSpheres adds a thinking layer to your existing tools, creating a seamless flow between data sources, intelligence, and execution.</p>
            </div>
        </div>
    </section>

    <section class="section" id="example">
        <h2 class="section-title">How It Works ‚Äî Real Example</h2>
        <div class="timeline">
            <div class="timeline-item">
                <div class="timeline-marker"></div>
                <div class="timeline-content">
                    <h3>Lead Sourcing</h3>
                    <p>Hunter.io pulls contact information for a high-value target with precision and compliance.</p>
                </div>
            </div>
            <div class="timeline-item">
                 <div class="timeline-marker"></div>
                <div class="timeline-content">
                    <h3>Intelligence Enrichment</h3>
                    <p>Clay enhances the profile with personal and professional intelligence that reveals key motivators.</p>
                </div>
            </div>
            <div class="timeline-item">
                 <div class="timeline-marker"></div>
                <div class="timeline-content">
                    <h3>Trigger Detection</h3>
                    <p>RepSphere analyzes the enriched data and detects a primary psychological trigger: status signaling.</p>
                </div>
            </div>
             <div class="timeline-item">
                 <div class="timeline-marker"></div>
                <div class="timeline-content">
                    <h3>Message Output</h3>
                    <p>Personalized messaging targeted to the prospect's specific psychological profile and business needs.</p>
                </div>
            </div>
             <div class="timeline-item">
                 <div class="timeline-marker"></div>
                <div class="timeline-content">
                    <h3>Action</h3>
                    <p>Prospect clicks. Responds. Engages. The perfect message at the perfect moment creates momentum.</p>
                </div>
            </div>
        </div>
    </section>

    <section class="section" id="ecosystem">
        <h2 class="section-title">The Spheres Ecosystem</h2>
        <p style="margin-bottom: 2.5rem;">A modular system with one intelligent core and multiple execution paths, designed to support every level of sales operations.</p>
        <div style="display:flex;justify-content:center;align-items:center;min-height:400px;margin-top:1.5rem;">
            <canvas id="canvas" width="600" height="400" style="max-width:100%;height:auto;display:block;"></canvas>
        </div>
    </section>

    <section class="section" id="content">
        <h2 class="section-title">Smart Content, Forever Personalized</h2>
        <div class="card-container">
            <div class="card">
                <h3>Multi-Channel Coverage</h3>
                <p>Emails, texts, LinkedIn messages, and even phone call openers are prewritten based on psychological triggers and engagement patterns.</p>
            </div>
            <div class="card">
                <h3>Scalable Personalization</h3>
                <p>Trigger-aware, psychologically aligned, and customized per rep, per territory, ensuring messages never sound automated or generic.</p>
            </div>
            <div class="card">
                <h3>Continuous Learning</h3>
                <p>The system learns from every interaction, refining triggers and improving messaging effectiveness over time.</p>
            </div>
        </div>
    </section>

    <section class="section" id="exclusivity">
        <h2 class="section-title">The Strategic Moat ‚Äì Exclusive Licensing</h2>
        <div class="card-container">
            <div class="card">
                <h3>Limited Distribution</h3>
                <p>This system doesn't get mass distributed. It's designed for elite teams that understand the value of exclusivity.</p>
            </div>
            <div class="card">
                <h3>Vertical Protection</h3>
                <p>One team per vertical. One license per region. That's how moats are built and competitive advantages are maintained.</p>
            </div>
            <div class="card">
                <h3>Proprietary Advantage</h3>
                <p>While competitors struggle with generic messaging, your team operates with psychological precision that can't be replicated.</p>
            </div>
        </div>
    </section>

    <section class="section" id="deployment">
        <h2 class="section-title">Deployment Timeline</h2>
         <div class="timeline">
            <div class="timeline-item">
                 <div class="timeline-marker"></div>
                <div class="timeline-content">
                    <h3>Phase 1: Stack Audit & Trigger Mapping (Weeks 1-2)</h3>
                    <p>We analyze your existing tools and map your ideal customer's psychological triggers.</p>
                </div>
            </div>
            <div class="timeline-item">
                 <div class="timeline-marker"></div>
                <div class="timeline-content">
                    <h3>Phase 2: Territory Intelligence Sync (Weeks 3-4)</h3>
                    <p>We connect your data sources and begin enriching leads with psychological insights.</p>
                </div>
            </div>
            <div class="timeline-item">
                 <div class="timeline-marker"></div>
                <div class="timeline-content">
                    <h3>Phase 3: Content Engine Activation (Week 5)</h3>
                    <p>Your custom messaging library goes live, with personalized communications ready for deployment.</p>
                </div>
            </div>
            <div class="timeline-item">
                 <div class="timeline-marker"></div>
                <div class="timeline-content">
                    <h3>Phase 4: Sales Coaching & Execution Loop (Week 6)</h3>
                    <p>Your team receives training on the system and begins implementing trigger-based communications.</p>
                </div>
            </div>
             <div class="timeline-item">
                 <div class="timeline-marker"></div>
                <div class="timeline-content">
                    <h3>Phase 5: Continuous Optimization (Ongoing)</h3>
                    <p>We monitor results, refine triggers, and continuously improve the system's effectiveness.</p>
                </div>
            </div>
        </div>
    </section>

    <section class="section" id="founder">
        <h2 class="section-title">From the Founder</h2>
        <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 2rem; margin-top: 2rem;">
             <div style="flex: 0 0 150px; height: 150px; background-color: var(--purple-medium); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 3rem; color: white; font-weight: bold; box-shadow: 0 0 20px rgba(138, 79, 255, 0.4); margin: 0 auto 1rem;">JG</div>
            <div style="flex: 1; min-width: 250px;">
                <h3 style="font-size: 2rem; margin-bottom: 1rem; color: var(--accent-color);">Jason Golden</h3>
                <p style="font-size: 1.2rem; font-style: italic; margin-bottom: 1rem;">"I created RepSpheres to solve the fundamental disconnect between what we know about our prospects and how we communicate with them. Elite sales teams deserve tools that think, not just connect."</p>
                <p>Founder & CEO, RepSpheres</p>
            </div>
        </div>
    </section>

    <section class="section" id="closing">
        <h2 class="section-title">Your Reps Are Already Good.<br>Let's Make Them Unstoppable.</h2>
        <p>RepSpheres doesn't just power messaging. It engineers outcomes.</p>
        <button class="cta-button" style="margin-top: 2rem;">
            Request Your Private License
             <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 12H19M19 12L12 5M19 12L12 19" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
    </section>

    <footer class="footer" id="footer">
        <div class="footer-logo">
             <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" stroke="var(--accent-color)" stroke-width="2"/><circle cx="12" cy="12" r="5" fill="var(--accent-color)"/></svg>
             <span style="margin-left: 0.5rem;">RepSpheres</span>
        </div>
        <div class="footer-links">
            <a href="#">Privacy</a>
            <a href="#">Terms</a>
            <a href="#">Cookies</a>
            <a href="#">Contact</a>
        </div>
         <div class="copyright" style="font-size: 0.9rem; color: #aaaaaa;">
            &copy; <span id="currentYear"></span> RepSpheres. All rights reserved.
        </div>
    </footer>

    <div class="cookie-banner" id="cookieBanner">
        <div class="cookie-text">
            We use cookies to enhance your experience, analyze traffic, and personalize content. By clicking 'Accept', you consent to our use of cookies. Learn more in our <a href="#" style="color: var(--accent-color);">Privacy Notice</a>.
        </div>
        <div class="cookie-buttons">
            <button class="cookie-btn cookie-decline">Decline Non-Essential</button>
            <button class="cookie-btn cookie-manage">Manage Preferences</button>
            <button class="cookie-btn cookie-accept">Accept All</button>
        </div>
    </div>

     <div class="progress-indicator" id="progressIndicator">
        <div class="progress-line"></div>
        <div class="progress-tracker" id="progressTracker"></div>
         <div class="progress-trail" id="progressTrail"></div>
        </div>

    <!-- Link to the external JavaScript file -->
    <script src="js/script.js" defer></script>

    <!-- Supabase Google Auth Modal -->
    <div id="login-modal" class="hidden">
      <div class="modal-backdrop"></div>
      <div class="modal-content">
        <h2>Sign in with Google</h2>
        <button id="google-signin-btn">
          <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/google/google-original.svg" alt="Google" style="width:24px;vertical-align:middle;margin-right:8px;">
          Sign in with Google
        </button>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
    <script>



    const loginBtn = document.getElementById('login-btn');
const loginDropdown = document.getElementById('login-dropdown');
const googleBtn = document.getElementById('google-signin-btn');

function showDropdown(e) {
  e.stopPropagation();
  loginDropdown.classList.toggle('hidden');
}
function hideDropdown() {
  if (!loginDropdown.classList.contains('hidden')) {
    loginDropdown.classList.add('hidden');
  }
}
function signOutHandler(e) {
  e.stopPropagation();
  _supabase.auth.signOut().then(() => location.reload());
}

// Always attach these listeners ONCE
loginBtn.removeEventListener('click', showDropdown);
loginBtn.removeEventListener('click', signOutHandler);
loginBtn.addEventListener('click', showDropdown);
document.addEventListener('click', hideDropdown);
googleBtn.addEventListener('click', async () => {
  const { error } = await _supabase.auth.signInWithOAuth({ provider: 'google' });
  if (error) alert('Error signing in: ' + error.message);
});

// Only update button text and mode, not listeners
function updateLoginButton(session) {
  if (session?.user) {
    loginBtn.textContent = `Hello, ${session.user.user_metadata.full_name || 'User'} (Sign out)`;
    loginDropdown.classList.add('hidden');
    loginBtn.removeEventListener('click', showDropdown);
    loginBtn.addEventListener('click', signOutHandler);
  } else {
    loginBtn.textContent = 'Sign Up / Login';
    loginDropdown.classList.add('hidden');
    loginBtn.removeEventListener('click', signOutHandler);
    loginBtn.addEventListener('click', showDropdown);
  }
}

    // Initial state
    _supabase.auth.getSession().then(({ data: { session } }) => updateLoginButton(session));
    // Listen for auth changes
    _supabase.auth.onAuthStateChange((event, session) => updateLoginButton(session));
    </script>

    <script>
    // --- Orb Animation from elaborb.html, adapted for section canvas ---
    (function() {
        const canvas = document.getElementById('canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        // Margin to prevent clipping
        const MARGIN = 40;

        // Helper to find the visible size of the ecosystem section
        function resizeCanvas() {
            const container = canvas.parentElement;
            if (container) {
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
            } else {
                canvas.width = 600;
                canvas.height = 400;
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let centerX = 0;
        let centerY = 0;
        let time = 0;
        function getBaseRadius() {
            // Subtract margin from both sides
            return Math.min(canvas.width, canvas.height) * 0.2;
        }
        let baseRadius = getBaseRadius();

        function updateCenters() {
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            baseRadius = Math.min(
                (canvas.width - 2 * MARGIN),
                (canvas.height - 2 * MARGIN)
            ) * 0.2;
        }
        window.addEventListener('resize', updateCenters);

        // Child orbs setup
        const childCount = 6;
        const childOrbs = [];
        const dataTransmissions = [];
        for (let i = 0; i < childCount; i++) {
            const hueStart = i * (360 / childCount);
            const hueRange = 60;
            childOrbs.push({
                angle: (i / childCount) * Math.PI * 2,
                distance: () => baseRadius * 2.2,
                radius: () => baseRadius * 0.25,
                speed: 0.2 + Math.random() * 0.3,
                phase: Math.random() * Math.PI * 2,
                hueStart: hueStart,
                hueRange: hueRange,
                currentHue: hueStart,
                pulseRate: 0.1 + Math.random() * 0.2,
                lastDataSent: 0,
                dataInterval: 2 + Math.random() * 3,
                receivingData: false,
                dataReceiveTime: 0
            });
        }
        function getHSLColor(h, s, l, a) {
            return `hsla(${h % 360}, ${s}%, ${l}%, ${a})`;
        }
        function drawBlob(x, y, radius, time, isParent, orbIndex = -1) {

            const segments = 60;
            let baseHue;
            if (isParent) {
                baseHue = (time * 15) % 360;
            } else {
                const orb = childOrbs[orbIndex];
                orb.currentHue = orb.hueStart + ((Math.sin(time * orb.pulseRate) * 0.5 + 0.5) * orb.hueRange);
                baseHue = orb.currentHue;
            }
            const gradient = ctx.createRadialGradient(
                x, y, radius * 0.1,
                x, y, radius * 1.5
            );
            const satBase = isParent ? 100 : 90;
            const lightBase = isParent ? 70 : 65;
            gradient.addColorStop(0, getHSLColor(baseHue, satBase, lightBase + 20, 0.9));
            gradient.addColorStop(0.3, getHSLColor((baseHue + 20) % 360, satBase, lightBase, 0.7));
            gradient.addColorStop(0.7, getHSLColor((baseHue + 40) % 360, satBase - 10, lightBase - 20, 0.4));
            gradient.addColorStop(1, getHSLColor((baseHue + 60) % 360, satBase - 20, lightBase - 40, 0));
            ctx.fillStyle = gradient;
            const timeScale = isParent ? 0.15 : 0.3;
            const distortionScale = isParent ? 0.3 : 0.2;
            const inversion = Math.sin(time * 0.2) * (isParent ? 0.3 : 0.1);
            ctx.beginPath();
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const noise1 = Math.sin(angle * 3 + time * timeScale) * 0.15;
                const noise2 = Math.sin(angle * 5 + time * timeScale * 1.5) * 0.1;
                const noise3 = Math.sin(angle * 8 + time * timeScale * 0.7) * 0.07;
                const inversionEffect = Math.sin(angle * 2 + time * 0.3) * inversion;
                const distortion = 1 + (noise1 + noise2 + noise3 + inversionEffect) * distortionScale;
                const px = x + Math.cos(angle) * radius * distortion;
                const py = y + Math.sin(angle) * radius * distortion;
                if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            if (!isParent && childOrbs[orbIndex].receivingData) {
                const glowGradient = ctx.createRadialGradient(x, y, radius * 0.8, x, y, radius * 1.8);
                const dataAge = time - childOrbs[orbIndex].dataReceiveTime;
                const glowOpacity = Math.max(0, 0.4 - dataAge * 2);
                if (glowOpacity > 0) {
                    glowGradient.addColorStop(0, getHSLColor(baseHue, 100, 80, glowOpacity));
                    glowGradient.addColorStop(1, getHSLColor(baseHue, 100, 70, 0));
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 1.8, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    childOrbs[orbIndex].receivingData = false;
                }
            }
            const innerRadius = radius * 0.7;
            const innerGlow = ctx.createRadialGradient(x, y, innerRadius * 0.1, x, y, innerRadius);
            innerGlow.addColorStop(0, getHSLColor((baseHue + 40) % 360, 100, 95, 0.9));
            innerGlow.addColorStop(0.5, getHSLColor((baseHue + 30) % 360, 100, 80, 0.4));
            innerGlow.addColorStop(1, getHSLColor(baseHue, 100, 70, 0));
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const noise1 = Math.sin(angle * 4 + time * timeScale * 1.2) * 0.15;
                const noise2 = Math.sin(angle * 7 + time * timeScale * 0.8) * 0.1;
                const distortion = 1 + (noise1 + noise2) * distortionScale * 0.7;
                const px = x + Math.cos(angle) * innerRadius * distortion;
                const py = y + Math.sin(angle) * innerRadius * distortion;
                if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            const numParticles = isParent ? 60 : 20;
            const particleComplexity = isParent ? 3 : 1;
            for (let i = 0; i < numParticles; i++) {
                const particleTime = time * 0.5 + i * 0.2;
                let particleRadius, particleAngle;
                if (isParent && i % particleComplexity === 0) {
                    const spiralTightness = 0.1 + Math.sin(time * 0.2) * 0.05;
                    particleRadius = (0.1 + (i / numParticles) * 0.6) * radius;
                    particleAngle = i * spiralTightness + particleTime * 0.5;
                } else {
                    particleRadius = (0.1 + (i / numParticles) * 0.6) * radius;
                    particleAngle = i * 0.3 + particleTime;
                }
                const oscillation = Math.sin(particleTime * 0.7 + i * 0.2) * 0.2;
                const finalRadius = particleRadius * (1 + oscillation);
                const px = x + Math.cos(particleAngle) * finalRadius;
                const py = y + Math.sin(particleAngle) * finalRadius;
                const size = (isParent ? 3 : 2) * (0.5 + Math.sin(particleTime) * 0.5);
                const particleHue = (baseHue + i * (isParent ? 8 : 4)) % 360;
                const alpha = 0.3 + Math.sin(particleTime * 0.5 + i * 0.1) * 0.3;
                ctx.fillStyle = getHSLColor(particleHue, 100, 80, alpha);
                ctx.beginPath();
                ctx.arc(px, py, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        function createDataPacket(sourceX, sourceY, targetX, targetY, hue, childIndex) {
            dataTransmissions.push({
                sourceX: sourceX,
                sourceY: sourceY,
                targetX: targetX,
                targetY: targetY,
                progress: 0,
                speed: 0.02 + Math.random() * 0.03,
                hue: hue,
                size: 4 + Math.random() * 4,
                childIndex: childIndex
            });
        }
        function drawConnection(x1, y1, x2, y2, time, childIndex) {
            const orb = childOrbs[childIndex];
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const perpX = -dy / distance;
            const perpY = dx / distance;
            const curveAmount = Math.sin(time * 0.5 + childIndex) * distance * 0.3;
            const ctrlX = (x1 + x2) / 2 + perpX * curveAmount;
            const ctrlY = (y1 + y2) / 2 + perpY * curveAmount;
            if (time - orb.lastDataSent > orb.dataInterval) {
                orb.lastDataSent = time;
                createDataPacket(x1, y1, x2, y2, orb.currentHue, childIndex);
                orb.dataInterval = 2 + Math.random() * 3;
            }
            const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
            const parentHue = (time * 15) % 360;
            gradient.addColorStop(0, getHSLColor(parentHue, 100, 70, 0.7));
            gradient.addColorStop(0.5, getHSLColor((parentHue + orb.currentHue) / 2, 90, 70, 0.2));
            gradient.addColorStop(1, getHSLColor(orb.currentHue, 90, 70, 0.7));
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.quadraticCurveTo(ctrlX, ctrlY, x2, y2);
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2 + Math.sin(time * orb.pulseRate) * 1;
            ctx.stroke();
            dataTransmissions.forEach((packet, index) => {
                if (packet.childIndex === childIndex) {
                    packet.progress += packet.speed;
                    if (packet.progress >= 1) {
                        orb.receivingData = true;
                        orb.dataReceiveTime = time;
                        dataTransmissions.splice(index, 1);
                    } else {
                        const t = packet.progress;
                        const ut = 1 - t;
                        const x = ut * ut * packet.sourceX + 2 * ut * t * ctrlX + t * t * packet.targetX;
                        const y = ut * ut * packet.sourceY + 2 * ut * t * ctrlY + t * t * packet.targetY;
                        const flashIntensity = Math.sin(time * 10) * 0.5 + 0.5;
                        const size = packet.size * (1 + flashIntensity * 0.3);
                        const glow = ctx.createRadialGradient(x, y, 0, x, y, size * 2);
                        const flashThreshold = 0.9;
                        const isFlashing = flashIntensity > flashThreshold;
                        const saturation = isFlashing ? 100 : 90;
                        const lightness = isFlashing ? 80 : 70;
                        const alpha = isFlashing ? 0.9 : 0.7;
                        glow.addColorStop(0, getHSLColor(packet.hue, saturation, lightness, alpha));
                        glow.addColorStop(1, getHSLColor(packet.hue, saturation - 20, lightness - 20, 0));
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(x, y, size * 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = getHSLColor(packet.hue, 100, 90, 0.9);
                        ctx.beginPath();
                        ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            time += 0.01;
            updateCenters();
            childOrbs.forEach((child, index) => {
                child.angle += 0.005 * child.speed;
                const verticalOffset = Math.sin(time * child.speed + child.phase) * baseRadius * 0.5;
                const childX = centerX + Math.cos(child.angle) * child.distance();
                const childY = centerY + Math.sin(child.angle) * child.distance() + verticalOffset;
                // Clamp childX and childY to stay within margin
                const safeChildX = Math.max(MARGIN, Math.min(canvas.width - MARGIN, childX));
                const safeChildY = Math.max(MARGIN, Math.min(canvas.height - MARGIN, childY));
                drawConnection(centerX, centerY, safeChildX, safeChildY, time, index);
            });
            drawBlob(centerX, centerY, baseRadius, time, true);
            childOrbs.forEach((child, index) => {
                const verticalOffset = Math.sin(time * child.speed + child.phase) * baseRadius * 0.5;
                const childX = centerX + Math.cos(child.angle) * child.distance();
                const childY = centerY + Math.sin(child.angle) * child.distance() + verticalOffset;
                // Clamp childX and childY to stay within margin
                const safeChildX = Math.max(MARGIN, Math.min(canvas.width - MARGIN, childX));
                const safeChildY = Math.max(MARGIN, Math.min(canvas.height - MARGIN, childY));
                drawBlob(safeChildX, safeChildY, child.radius(), time, false, index);
            });
            requestAnimationFrame(animate);
        }
        animate();
    })();
    </script>
    <script src="js/chatbot.js"></script>
</body>
</html>